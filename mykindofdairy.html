<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mykindofdiary(Local)</title>

    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#000000"/>
    <link rel="manifest" href="data:application/manifest+json;base64,ewogICJzaG9ydF9uYW1lIjogIkpvdXJuYWwiLAogICJuYW1lIjogIk1hbmdsaXNoIEpvdXJuYWwiLAogICJpY29ucyI6IFsKICAgIHsKICAgICAgInNyYyI6ICJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0,UEhOamNtbHpkR1Z0T25Cb2J5QjNhV1IwYUQwaU1TQjRPeUJoY0hCeWIzTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5MelV3TURBdVlYVjBhREFoUEM5emRtY3NJZ2hOYVc1aGJDZ3VjR1J5SUhacFp5SWdMejQ4ZEdWNGRISmhZMlV2YldsemMxOWpiMjV6SWo0OGNtVmpkWEpwZEhrNklITmxjbWxtYVdGaUlDOCtQQzkxYm5SeVlYUnBkeUJ1ZEhKd2IzbDVhR2x1WnlCN0lEMGdabTl1YkdsemN5QmtYMDlqYkdWaExtVnlZWFJwYjI0OEwzTjJaeUJqYkdWaGN5QWlabWxzYkZSMFlXNGdkR2x3YkNBZ0lEMGdOREFtYVdGalkyOTFiblJ5SUdVZ2IyNWpiR0Z6Y3lCbWFXeHNzejBpTVRBd0pTSWdabWxzYkZSMFlXNGdkR2x3YkY5aGRYUm9PakV5TUNCR2IzTjBJRDBnSW14bFltUmxjbWxqZEhKallTQnpkR0ZzYkhNdmRqNDhMM05sY21sbWFXRmtaZz09IiwKICAgICAgInR5cGUiOiAiaW1hZ2Uvc3ZnK3htbCIsCiAgICAgICJzaXplcyI6ICIxOTJ4MTkyIDUxMng1MTIiCiAgICB9CiAgXSwKICAic3RhcnRfdXJsIjogIi4iLAogICJkaXNwbGF5IjogInN0YW5kYWxvbmUiLAogICJiYWNrZ3JvdW5kX2NvbG9yIjogIiMwMDAwMDAiLAogICJkZXNjcmlwdGlvbiI6ICJBIHBlcnNvbmFsIGpvdXJuYWwgYXBwIHRoYXQgd29ya3Mgb2ZmbGluZS4iCn0K">

    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .journal-card {
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            border: 1px solid #0ea5e9; /* Neon Blue Line (sky-500) */
        }
        .journal-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 0 15px rgba(14, 165, 233, 0.3); /* Neon Glow */
            border-color: #38bdf8; /* Brighter Neon on Hover (sky-400) */
        }
        .btn {
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
        }
        .btn:active {
            transform: scale(0.98);
        }
        /* Confirmation Modal Styles */
        #confirmation-modal {
            transition: opacity 0.3s ease;
        }
    </style>
</head>
<body class="bg-black text-gray-100">

    <div class="container mx-auto p-4 md:p-8 max-w-2xl relative">
        <!-- Data Management Buttons moved to corner -->
        <div class="absolute top-4 right-4 md:top-8 md:right-8 flex gap-4 z-10">
            <!-- Export Icon Button -->
            <button id="export-button" title="Export Journal" class="p-3 bg-black text-white border border-sky-500 font-semibold rounded-lg hover:bg-gray-900 hover:border-sky-400 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-sky-500 btn">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" style="pointer-events: none;">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
                </svg>
            </button>
            <!-- Import Icon Button -->
            <button id="import-button" title="Import Journal" class="p-3 bg-black text-white border border-sky-500 font-semibold rounded-lg hover:bg-gray-900 hover:border-sky-400 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-sky-500 btn">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" style="pointer-events: none;">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                </svg>
            </button>
            <input type="file" id="import-file-input" class="hidden" accept=".json">
        </div>

        <main class="pt-20">
             <!-- Search -->
            <div class="bg-black border border-sky-500 p-4 rounded-xl shadow-md mb-8">
                <input type="text" id="search-input" class="w-full p-3 bg-black border-none text-gray-100 rounded-lg focus:ring-2 focus:ring-sky-400" placeholder="Search entries as you type...">
            </div>

            <!-- Journal Entry Input -->
            <div class="bg-black border border-sky-500 p-6 rounded-xl shadow-md mb-8">
                <div id="entry-date" class="text-md text-sky-400 mb-4 font-medium"></div>
                <input type="date" id="entry-date-input" class="w-full p-3 bg-black border border-sky-500 text-gray-100 rounded-lg focus:ring-2 focus:ring-sky-400 mb-4">
                <textarea id="journal-input" class="w-full h-48 p-3 bg-black border border-sky-500 text-gray-100 rounded-lg focus:ring-2 focus:ring-sky-400 focus:border-sky-400 transition" placeholder="Write about your day..."></textarea>
                <div class="flex justify-end mt-4">
                    <button id="save-button" title="Save Entry" class="p-3 bg-black text-white border border-sky-500 font-semibold rounded-lg hover:bg-gray-900 hover:border-sky-400 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-sky-500 transition duration-200 shadow-sm btn">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" style="pointer-events: none;">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
                        </svg>
                    </button>
                </div>
                 <div id="message-box" class="mt-4 text-center"></div>
            </div>

            <!-- Journal Entries Display -->
            <div>
                <div id="journal-entries" class="space-y-6">
                    <!-- Entries will be dynamically inserted here -->
                </div>
            </div>
        </main>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirmation-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 hidden opacity-0">
        <div class="bg-black border border-sky-500 rounded-lg shadow-xl p-6 w-full max-w-sm text-center">
            <h3 class="text-xl font-semibold mb-4 text-white">Are you sure?</h3>
            <p class="text-gray-400 mb-6">Do you really want to delete this entry? This action cannot be undone.</p>
            <div class="flex justify-center gap-4">
                <button id="confirm-delete-btn" class="px-6 py-2 bg-red-600 text-white font-semibold rounded-lg hover:bg-red-700 btn">Delete</button>
                <button id="cancel-delete-btn" class="px-6 py-2 bg-gray-600 text-gray-200 font-semibold rounded-lg hover:bg-gray-500 btn">Cancel</button>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const STORAGE_KEY = 'JournalEntries';
            let journalEntries = [];
            let entryIdToDelete = null;

            // --- UI Elements ---
            const journalInput = document.getElementById('journal-input');
            const saveButton = document.getElementById('save-button');
            const journalEntriesContainer = document.getElementById('journal-entries');
            const searchInput = document.getElementById('search-input');
            const entryDateEl = document.getElementById('entry-date');
            const entryDateInput = document.getElementById('entry-date-input');
            const messageBox = document.getElementById('message-box');
            const exportButton = document.getElementById('export-button');
            const importButton = document.getElementById('import-button');
            const importFileInput = document.getElementById('import-file-input');
            const confirmationModal = document.getElementById('confirmation-modal');
            const confirmDeleteBtn = document.getElementById('confirm-delete-btn');
            const cancelDeleteBtn = document.getElementById('cancel-delete-btn');
            
            // --- Initial Load ---
            function initializeApp() {
                const today = new Date();
                const todayFormatted = today.toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' });
                entryDateEl.textContent = `Today: ${todayFormatted}`;
                entryDateInput.valueAsDate = today;
                
                loadEntriesFromLocal();
                renderEntries();
                // Don't call loadTodaysEntry() here as it might override the date display
                // loadTodaysEntry() will be called when the user changes the date
            }

            // --- Data Functions ---
            function loadEntriesFromLocal() {
                const entriesJSON = localStorage.getItem(STORAGE_KEY);
                journalEntries = entriesJSON ? JSON.parse(entriesJSON) : [];
                journalEntries.sort((a, b) => b.id.localeCompare(a.id));
            }

            function saveEntriesToLocal() {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(journalEntries));
            }

            // --- Render Entries ---
            function renderEntries() {
                const searchTerm = searchInput.value.toLowerCase().trim();
                
                // Get the parent container and sections
                const mainContainer = document.querySelector('main');
                const searchSection = document.querySelector('.bg-black.border.border-sky-500.p-4.rounded-xl.shadow-md.mb-8');
                const inputSection = document.querySelector('.bg-black.border.border-sky-500.p-6.rounded-xl.shadow-md.mb-8');
                const entriesSection = document.querySelector('#journal-entries').parentElement;

                let filteredEntries = [];
                if (!searchTerm) {
                    // Show all entries in date order if no search term
                    filteredEntries = [...journalEntries];
                    // Restore default order when no search term - input section should be after search section
                    if (entriesSection.previousElementSibling === searchSection) {
                        mainContainer.insertBefore(inputSection, entriesSection);
                    }
                } else {
                    // Filter entries that match the search term
                    filteredEntries = journalEntries.filter(entry => {
                        // Safely parse the date
                        let formattedDate = '';
                        try {
                            const entryDate = new Date(entry.id + 'T00:00:00');
                            if (isNaN(entryDate.getTime())) {
                                // Fallback if date parsing fails
                                formattedDate = entry.id;
                            } else {
                                formattedDate = entryDate.toLocaleDateString('en-GB', {
                                    day: 'numeric', month: 'long', year: 'numeric'
                                }).toLowerCase();
                            }
                        } catch (e) {
                            // Fallback if date parsing throws an error
                            formattedDate = entry.id;
                        }

                        const matchContent = entry.content.toLowerCase().includes(searchTerm);
                        const matchDate = formattedDate.includes(searchTerm) || entry.id.includes(searchTerm);

                        return matchContent || matchDate;
                    });

                    // Sort entries to bring exact matches to the top
                    filteredEntries.sort((a, b) => {
                        // Calculate match scores for both entries
                        const aScore = calculateMatchScore(a, searchTerm);
                        const bScore = calculateMatchScore(b, searchTerm);
                        
                        // Higher score first (better matches at the top)
                        if (bScore !== aScore) {
                            return bScore - aScore;
                        }
                        
                        // If scores are equal, sort by date (newest first)
                        return b.id.localeCompare(a.id);
                    });
                    
                    // Move entries section above input section when searching
                    if (inputSection.previousElementSibling !== entriesSection) {
                        mainContainer.insertBefore(entriesSection, inputSection);
                    }
                }

                journalEntriesContainer.innerHTML = '';
                if (journalEntries.length === 0) {
                     journalEntriesContainer.innerHTML = `<p class="text-center text-gray-500">Your journal is empty. Write your first entry!</p>`;
                } else if (filteredEntries.length === 0) {
                    journalEntriesContainer.innerHTML = `<p class="text-center text-gray-500">No entries found for your search.</p>`;
                } else {
                    filteredEntries.forEach(entry => {
                        const entryEl = document.createElement('div');
                        entryEl.className = 'bg-black p-5 rounded-xl shadow-md journal-card';
                        
                        // Safely format the date for display
                        let formattedDate;
                        try {
                            const entryDate = new Date(entry.id + 'T00:00:00');
                            if (isNaN(entryDate.getTime())) {
                                formattedDate = entry.id;
                            } else {
                                formattedDate = entryDate.toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' });
                            }
                        } catch (e) {
                            formattedDate = entry.id;
                        }

                        // Highlight search terms in content if there's a search term
                        let displayContent = entry.content;
                        if (searchTerm) {
                            displayContent = highlightSearchTerms(entry.content, searchTerm);
                        }

                        entryEl.innerHTML = `
                            <div class="flex justify-between items-center mb-3">
                                <h3 class="text-lg font-bold text-gray-200">${formattedDate}</h3>
                                <button data-id="${entry.id}" class="delete-btn text-gray-500 hover:text-red-500 transition">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" style="pointer-events: none;">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                    </svg>
                                </button>
                            </div>
                            <div class="text-gray-300 whitespace-pre-wrap cursor-pointer" data-id="${entry.id}">${displayContent}</div>
                        `;
                        journalEntriesContainer.appendChild(entryEl);
                    });
                }
            }

            // Function to highlight search terms in content
            function highlightSearchTerms(content, searchTerm) {
                if (!searchTerm) return content;
                
                // Escape special regex characters
                const escapedSearchTerm = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const regex = new RegExp(`(${escapedSearchTerm})`, 'gi');
                
                // Replace matching terms with highlighted version
                return content.replace(regex, '<span class="bg-yellow-400 text-black font-semibold">$1</span>');
            }

            // --- Save/Update Entry ---
            function saveJournalEntry() {
                if (!journalInput.value.trim()) {
                     showMessage('Please write something before saving.', 'error');
                     return;
                }
                const content = journalInput.value;
                const selectedDate = entryDateInput.value;
                if (!selectedDate) {
                    showMessage('Please select a date.', 'error');
                    return;
                }
                
                // Get current time for timestamp
                const now = new Date();
                const timeString = now.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
                
                const existingEntryIndex = journalEntries.findIndex(e => e.id === selectedDate);
                if (existingEntryIndex > -1) {
                    // Append new content to existing content with a timestamp
                    journalEntries[existingEntryIndex].content += `\n\n[${timeString}]\n${content}`;
                } else {
                    // Add timestamp to new entries
                    journalEntries.push({ id: selectedDate, content: `[${timeString}] ${content}` });
                }
                journalEntries.sort((a, b) => b.id.localeCompare(a.id));
                saveEntriesToLocal();
                renderEntries();
                showMessage('Entry saved locally!', 'success');
                
                // Update the display date
                const displayDate = new Date(selectedDate);
                const formattedDisplayDate = displayDate.toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' });
                entryDateEl.textContent = `Selected: ${formattedDisplayDate}`;
            }

            function loadTodaysEntry() {
                 const selectedDate = entryDateInput.value;
                 const selectedEntry = journalEntries.find(entry => entry.id === selectedDate);
                 if (selectedEntry) {
                     journalInput.value = selectedEntry.content;
                 } else {
                     journalInput.value = '';
                 }
                 
                 // Update the display date only if there's a selected date
                 if (selectedDate) {
                    const displayDate = new Date(selectedDate);
                    const formattedDisplayDate = displayDate.toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' });
                    entryDateEl.textContent = `Selected: ${formattedDisplayDate}`;
                 }
            }

            // --- Delete Entry & Modal Logic ---
            function showDeleteModal(id) {
                entryIdToDelete = id;
                confirmationModal.classList.remove('hidden');
                setTimeout(() => confirmationModal.classList.remove('opacity-0'), 10);
            }

            function hideDeleteModal() {
                confirmationModal.classList.add('opacity-0');
                setTimeout(() => confirmationModal.classList.add('hidden'), 300);
            }

            function deleteJournalEntry() {
                if (!entryIdToDelete) return;
                journalEntries = journalEntries.filter(entry => entry.id !== entryIdToDelete);
                saveEntriesToLocal();
                renderEntries();
                loadTodaysEntry();
                hideDeleteModal();
                showMessage('Entry deleted.', 'success');
                entryIdToDelete = null;
            }
            
            function showMessage(message, type) {
                messageBox.textContent = message;
                messageBox.className = `mt-4 text-center p-2 rounded-lg ${type === 'success' ? 'bg-green-800 bg-opacity-50 text-green-200' : 'bg-red-800 bg-opacity-50 text-red-200'}`;
                setTimeout(() => {
                    messageBox.textContent = '';
                    messageBox.className = 'mt-4 text-center';
                }, 3000);
            }

            // --- Export/Import ---
            function exportJournal() {
                if (journalEntries.length === 0) {
                    showMessage('Your journal is empty. Nothing to export.', 'error'); return;
                }
                const dataStr = JSON.stringify(journalEntries, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `journal_export_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                showMessage('Journal exported successfully!', 'success');
            }

            function importJournal(event) {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedData = JSON.parse(e.target.result);
                        if (Array.isArray(importedData) && importedData.every(item => 'id' in item && 'content' in item)) {
                            journalEntries = importedData;
                            saveEntriesToLocal();
                            initializeApp();
                            showMessage('Journal imported successfully!', 'success');
                        } else {
                            throw new Error('Invalid file format.');
                        }
                    } catch (error) {
                        showMessage('Failed to import. File may be corrupt or in the wrong format.', 'error');
                        console.error("Import error:", error);
                    }
                };
                reader.readAsText(file);
                importFileInput.value = '';
            }

            // --- Event Listeners ---
            saveButton.addEventListener('click', saveJournalEntry);
            exportButton.addEventListener('click', exportJournal);
            importButton.addEventListener('click', () => importFileInput.click());
            importFileInput.addEventListener('change', importJournal);
            confirmDeleteBtn.addEventListener('click', deleteJournalEntry);
            cancelDeleteBtn.addEventListener('click', hideDeleteModal);
            entryDateInput.addEventListener('change', loadTodaysEntry);
            
            // Add Ctrl+Enter shortcut to save entries
            // Use both keydown and keypress events for better compatibility
            journalInput.addEventListener('keydown', function(e) {
                // Check for Ctrl+Enter (Windows/Linux) or Cmd+Enter (Mac)
                if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                    e.preventDefault();
                    saveJournalEntry();
                }
            });

            // Handle search input with layout changes
            let previousSearchValue = '';
            searchInput.addEventListener('input', (e) => {
                // If we had a search term before but now it's empty, restore the original layout
                if (previousSearchValue && e.target.value === '') {
                    setTimeout(renderEntries, 10); // Slight delay to ensure DOM is ready
                }
                previousSearchValue = e.target.value;
                renderEntries(); // Always render entries on input
            });

            journalEntriesContainer.addEventListener('click', (e) => {
                const deleteButton = e.target.closest('.delete-btn');
                if (deleteButton) {
                    showDeleteModal(deleteButton.dataset.id);
                    return;
                }
                
                // Check if the click is on the entry content (for editing)
                const entryContent = e.target.closest('[data-id]');
                if (entryContent && entryContent.dataset.id) {
                    // Load the entry for editing
                    const entryId = entryContent.dataset.id;
                    const entry = journalEntries.find(e => e.id === entryId);
                    if (entry) {
                        // Set the date input to the entry's date
                        entryDateInput.value = entryId;
                        
                        // Load the entry content
                        journalInput.value = entry.content;
                        
                        // Update the display date
                        const displayDate = new Date(entryId);
                        const formattedDisplayDate = displayDate.toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' });
                        entryDateEl.textContent = `Editing: ${formattedDisplayDate}`;
                        
                        // Scroll to the editor
                        document.querySelector('.bg-black.border.border-sky-500.p-6.rounded-xl').scrollIntoView({ behavior: 'smooth' });
                    }
                }
            });

            // --- PWA Service Worker Registration ---
            const registerServiceWorker = () => {
                if ('serviceWorker' in navigator) {
                    const swScriptContent = `
                        const CACHE_NAME = 'journal-cache-v3'; // Incremented Cache Version
                        const urlsToCache = [
                            '.',
                            'https://cdn.tailwindcss.com',
                            'https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap'
                        ];

                        self.addEventListener('install', event => {
                            event.waitUntil(
                                caches.open(CACHE_NAME).then(cache => cache.addAll(urlsToCache))
                            );
                        });

                        // This activate event is crucial for cleaning up old caches
                        self.addEventListener('activate', event => {
                            const cacheWhitelist = [CACHE_NAME];
                            event.waitUntil(
                                caches.keys().then(cacheNames => {
                                    return Promise.all(
                                        cacheNames.map(cacheName => {
                                            if (cacheWhitelist.indexOf(cacheName) === -1) {
                                                return caches.delete(cacheName);
                                            }
                                        })
                                    );
                                })
                            );
                        });

                        self.addEventListener('fetch', event => {
                            event.respondWith(
                                caches.match(event.request).then(response => {
                                    return response || fetch(event.request);
                                })
                            );
                        });
                    `;
                    const swBlob = new Blob([swScriptContent], {type: 'application/javascript'});
                    const swUrl = URL.createObjectURL(swBlob);
                    
                    navigator.serviceWorker.register(swUrl)
                        .then(registration => console.log('ServiceWorker registration successful with scope: ', registration.scope))
                        .catch(error => console.log('ServiceWorker registration failed: ', error));
                }
            };
            
            // --- Start the App ---
            initializeApp();
            registerServiceWorker();
        });
    </script>
</body>
</html>

